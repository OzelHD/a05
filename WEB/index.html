<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Piano Preset Builder</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --ink: #1c1c1c;
      --muted: #5b616b;
      --paper: #fff7ec;
      --paper-2: #f7efe2;
      --accent: #006d77;
      --accent-2: #ff7a59;
      --line: #d6c8b3;
      --shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
      --row-h: 28px;
      --cell-w: 28px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--ink);
      font-family: "Space Grotesk", sans-serif;
      background:
        radial-gradient(900px 600px at 10% 10%, rgba(0, 109, 119, 0.08), transparent 55%),
        radial-gradient(700px 500px at 90% 15%, rgba(255, 122, 89, 0.08), transparent 50%),
        linear-gradient(140deg, #fef9f2, #f3ede2 65%, #e7efe9);
      padding: 32px 24px 56px;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background-image: linear-gradient(90deg, rgba(0,0,0,0.04) 1px, transparent 1px),
                        linear-gradient(180deg, rgba(0,0,0,0.035) 1px, transparent 1px);
      background-size: 120px 120px;
      pointer-events: none;
      opacity: 0.3;
    }

    header {
      max-width: 1200px;
      margin: 0 auto 28px;
    }

    h1 {
      font-family: "Fraunces", serif;
      font-size: clamp(28px, 4vw, 44px);
      margin: 0 0 8px;
      letter-spacing: 0.5px;
    }

    header p {
      margin: 0;
      color: var(--muted);
      max-width: 840px;
      line-height: 1.5;
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(260px, 360px) minmax(0, 1fr);
      gap: 24px;
    }

    .card {
      background: var(--paper);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 18px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255,122,89,0.08), transparent 60%);
      pointer-events: none;
    }

    .card > * { position: relative; }

    .section-title {
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin: 4px 0 14px;
      color: var(--muted);
    }

    .field {
      display: grid;
      gap: 6px;
      margin-bottom: 12px;
    }

    .range-row {
      display: grid;
      grid-template-columns: 1fr 90px;
      gap: 10px;
      align-items: center;
    }

    .range-row input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .hint-inline {
      font-size: 11px;
      color: var(--muted);
    }

    label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    input[type="text"],
    input[type="number"],
    textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #fffdf9;
      font-family: inherit;
      font-size: 14px;
      color: var(--ink);
    }

    input[type="number"] { appearance: textfield; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { appearance: none; margin: 0; }

    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .toggle input { accent-color: var(--accent); }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      margin-bottom: 12px;
    }

    .map-list {
      display: grid;
      gap: 10px;
      margin-bottom: 12px;
    }

    .map-row {
      display: grid;
      grid-template-columns: 34px 1fr 1.2fr 34px;
      gap: 8px;
      align-items: center;
    }

    .mini {
      border: 1px solid var(--line);
      background: #fffdf9;
      color: var(--ink);
      border-radius: 8px;
      width: 34px;
      height: 34px;
      font-weight: 600;
      cursor: pointer;
    }

    .mini:hover { border-color: var(--accent); color: var(--accent); }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      padding: 10px 14px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn.secondary {
      background: transparent;
      color: var(--accent);
    }

    .btn.ghost {
      border-color: var(--line);
      color: var(--ink);
      background: #fffdf9;
    }

    .staff-block { margin-bottom: 18px; }

    .staff-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .staff-title h2 {
      font-family: "Fraunces", serif;
      font-size: 20px;
      margin: 0;
    }

    .staff-title span {
      font-size: 12px;
      color: var(--muted);
    }

    .timeline-shell,
    .staff-shell {
      display: grid;
      grid-template-columns: 80px minmax(0, 1fr);
      align-items: start;
    }

    .timeline-label,
    .row-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      padding: 6px 8px 0;
    }

    .timeline {
      display: grid;
      grid-template-columns: repeat(var(--cols), minmax(var(--cell-w), 1fr));
      gap: 0;
      padding: 4px 0 4px 0;
      min-width: calc(var(--cols) * var(--cell-w));
    }

    .tick {
      font-size: 10px;
      text-align: center;
      color: var(--muted);
      padding: 2px 0;
      border-left: 1px solid rgba(0,0,0,0.06);
    }

    .tick.bar-start { border-left: 3px solid var(--accent); color: var(--accent); font-weight: 600; }
    .tick.start {
      background: rgba(0,109,119,0.14);
      color: var(--accent);
      font-weight: 600;
    }

    .staff-wrap {
      overflow-x: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fffdf9;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02);
    }

    .scroll-wrap {
      overflow-x: auto;
      scrollbar-gutter: stable both-edges;
    }

    .row-labels {
      display: grid;
      grid-auto-rows: var(--row-h);
      gap: 0;
      padding: 6px 6px 6px 4px;
    }

    .row-labels div {
      font-size: 12px;
      padding: 4px 6px;
      color: var(--muted);
    }

    .staff-grid {
      --rows: 1;
      display: grid;
      grid-template-columns: repeat(var(--cols), minmax(var(--cell-w), 1fr));
      grid-auto-rows: var(--row-h);
      min-width: calc(var(--cols) * var(--cell-w));
      position: relative;
    }

    .staff-grid::before {
      content: "";
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        transparent 0,
        transparent calc(var(--row-h) - 1px),
        rgba(0,0,0,0.08) calc(var(--row-h) - 1px),
        rgba(0,0,0,0.08) var(--row-h)
      );
      pointer-events: none;
    }

    .cell {
      border-right: 1px solid rgba(0,0,0,0.08);
      border-bottom: 1px solid rgba(0,0,0,0.08);
      background: transparent;
      padding: 0;
      cursor: pointer;
      position: relative;
    }

    .cell.bar-start { border-left: 3px solid var(--accent); box-shadow: inset 1px 0 0 rgba(0,109,119,0.35); }
    .cell.beat { background: rgba(0,109,119,0.05); }

    .cell.on::after {
      content: "";
      position: absolute;
      inset: 6px;
      border-radius: 6px;
      background: var(--accent-2);
      box-shadow: 0 4px 10px rgba(255,122,89,0.35);
    }

    textarea {
      min-height: 180px;
      resize: vertical;
      font-family: "Space Grotesk", sans-serif;
    }

    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
      .timeline-shell,
      .staff-shell { grid-template-columns: 70px minmax(0, 1fr); }
    }

    @media (max-width: 640px) {
      body { padding: 24px 16px 40px; }
      .map-row { grid-template-columns: 30px 1fr 1fr 30px; }
      .timeline-shell,
      .staff-shell { grid-template-columns: 60px minmax(0, 1fr); }
      .range-row { grid-template-columns: 1fr 70px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Piano Preset Builder</h1>
    <p>Place notes on two staves, 16 ticks per bar. The output matches your mcfunction format and updates live as you click.</p>
  </header>

  <main>
    <section class="card" aria-label="Settings">
      <div class="section-title">Song Settings</div>
      <div class="field">
        <label for="bars">Bars (each bar is 16 ticks)</label>
        <div class="range-row">
          <input type="range" id="barsRange" min="1" max="1024" value="8" />
          <input type="number" id="bars" min="1" max="1024" value="8" />
        </div>
        <div class="hint-inline" id="barsHint">Total ticks: 128</div>
      </div>
      <div class="field">
        <label for="startTick">Start tick (click tick header to set)</label>
        <input type="number" id="startTick" min="0" value="0" />
      </div>
      <div class="field">
        <label for="scoreHolder">Score holder</label>
        <input type="text" id="scoreHolder" value="#piano_song_time" />
      </div>
      <div class="field">
        <label for="scoreObjective">Score objective</label>
        <input type="text" id="scoreObjective" value="piano_song_time" />
      </div>
      <div class="field">
        <label for="functionPath">Function to run</label>
        <input type="text" id="functionPath" value="a05:piano/press_key" />
      </div>
      <div class="toggle">
        <input type="checkbox" id="autoTag" checked />
        <label for="autoTag">Auto-tag from label (C#3 -> piano_note_cs3)</label>
      </div>
      <div class="toggle">
        <input type="checkbox" id="loopToggle" />
        <label for="loopToggle">Repeat at end (jump back to start tick)</label>
      </div>
      <div class="hint">Use the # button on a row to toggle a sharp. Adjust labels/tags once at the beginning so the mapping matches your naming.</div>

      <div class="section-title">High Hand Mapping</div>
      <div class="map-list" id="highMap"></div>
      <div class="actions">
        <button class="btn" id="addHigh">Add high note</button>
      </div>

      <div class="section-title">Low Hand Mapping</div>
      <div class="map-list" id="lowMap"></div>
      <div class="actions">
        <button class="btn" id="addLow">Add low note</button>
        <button class="btn ghost" id="clearAll">Clear placed notes</button>
        <button class="btn ghost" id="resetStorage">Reset local storage</button>
      </div>
    </section>

    <section class="card" aria-label="Editor">
      <div class="staff-block">
        <div class="staff-title">
          <h2>High hand</h2>
          <span id="highCount">0 notes</span>
        </div>
        <div class="timeline-shell">
          <div class="timeline-label">ticks</div>
          <div class="scroll-wrap" data-sync="high">
            <div class="timeline" id="highTimeline"></div>
          </div>
        </div>
        <div class="staff-shell">
          <div class="row-labels" id="highLabels"></div>
          <div class="staff-wrap scroll-wrap" data-sync="high">
            <div class="staff-grid" id="highGrid"></div>
          </div>
        </div>
      </div>

      <div class="staff-block">
        <div class="staff-title">
          <h2>Low hand</h2>
          <span id="lowCount">0 notes</span>
        </div>
        <div class="timeline-shell">
          <div class="timeline-label">ticks</div>
          <div class="scroll-wrap" data-sync="low">
            <div class="timeline" id="lowTimeline"></div>
          </div>
        </div>
        <div class="staff-shell">
          <div class="row-labels" id="lowLabels"></div>
          <div class="staff-wrap scroll-wrap" data-sync="low">
            <div class="staff-grid" id="lowGrid"></div>
          </div>
        </div>
      </div>

      <div class="section-title">Generated mcfunction</div>
      <textarea id="output" readonly></textarea>
      <div class="actions">
        <button class="btn secondary" id="copyOutput">Copy to clipboard</button>
        <button class="btn ghost" id="downloadOutput">Download .mcfunction</button>
      </div>

      <div class="section-title">Import mcfunction</div>
      <textarea id="importInput" placeholder="Paste existing mcfunction lines here..."></textarea>
      <div class="actions">
        <button class="btn ghost" id="importBtn">Import to grid</button>
        <button class="btn ghost" id="clearImport">Clear import</button>
      </div>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "piano_preset_builder_v1";

    const state = {
      bars: 8,
      ticksPerBar: 16,
      startTick: 0,
      scrollLeft: 0,
      loopEnabled: false,
      autoTag: true,
      scoreHolder: "#piano_song_time",
      scoreObjective: "piano_song_time",
      functionPath: "a05:piano/press_key",
      highNotes: [],
      lowNotes: [],
      notes: {},
      nextId: 1
    };

    const elements = {
      bars: document.getElementById("bars"),
      barsRange: document.getElementById("barsRange"),
      barsHint: document.getElementById("barsHint"),
      startTick: document.getElementById("startTick"),
      loopToggle: document.getElementById("loopToggle"),
      scoreHolder: document.getElementById("scoreHolder"),
      scoreObjective: document.getElementById("scoreObjective"),
      functionPath: document.getElementById("functionPath"),
      autoTag: document.getElementById("autoTag"),
      highMap: document.getElementById("highMap"),
      lowMap: document.getElementById("lowMap"),
      highLabels: document.getElementById("highLabels"),
      lowLabels: document.getElementById("lowLabels"),
      highGrid: document.getElementById("highGrid"),
      lowGrid: document.getElementById("lowGrid"),
      highTimeline: document.getElementById("highTimeline"),
      lowTimeline: document.getElementById("lowTimeline"),
      highCount: document.getElementById("highCount"),
      lowCount: document.getElementById("lowCount"),
      output: document.getElementById("output"),
      importInput: document.getElementById("importInput"),
      importBtn: document.getElementById("importBtn"),
      clearImport: document.getElementById("clearImport"),
      addHigh: document.getElementById("addHigh"),
      addLow: document.getElementById("addLow"),
      clearAll: document.getElementById("clearAll"),
      resetStorage: document.getElementById("resetStorage"),
      copyOutput: document.getElementById("copyOutput"),
      downloadOutput: document.getElementById("downloadOutput")
    };

    const scrollState = {
      syncing: false,
      saveTimer: null
    };

    function saveState() {
      try {
        const payload = {
          bars: state.bars,
          ticksPerBar: state.ticksPerBar,
          startTick: state.startTick,
          scrollLeft: state.scrollLeft,
          loopEnabled: state.loopEnabled,
          autoTag: state.autoTag,
          scoreHolder: state.scoreHolder,
          scoreObjective: state.scoreObjective,
          functionPath: state.functionPath,
          highNotes: state.highNotes,
          lowNotes: state.lowNotes,
          notes: Object.fromEntries(
            Object.entries(state.notes).map(([id, set]) => [id, Array.from(set)])
          ),
          nextId: state.nextId
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (error) {
        /* ignore storage errors */
      }
    }

    function loadState() {
      let raw = null;
      try {
        raw = localStorage.getItem(STORAGE_KEY);
      } catch (error) {
        return false;
      }
      if (!raw) return false;
      let data = null;
      try {
        data = JSON.parse(raw);
      } catch (error) {
        return false;
      }
      if (!data || typeof data !== "object") return false;

      const bars = Number(data.bars);
      state.bars = Number.isFinite(bars) && bars > 0 ? Math.min(Math.max(1, bars), 1024) : state.bars;
      state.ticksPerBar = data.ticksPerBar === 16 ? 16 : state.ticksPerBar;
      const startTick = Number(data.startTick);
      state.startTick = Number.isFinite(startTick) && startTick >= 0 ? startTick : 0;
      const maxTick = state.bars * state.ticksPerBar - 1;
      if (state.startTick > maxTick) state.startTick = Math.max(0, maxTick);
      const scrollLeft = Number(data.scrollLeft);
      state.scrollLeft = Number.isFinite(scrollLeft) && scrollLeft >= 0 ? scrollLeft : 0;
      state.loopEnabled = !!data.loopEnabled;
      state.autoTag = !!data.autoTag;
      state.scoreHolder = typeof data.scoreHolder === "string" ? data.scoreHolder : state.scoreHolder;
      state.scoreObjective = typeof data.scoreObjective === "string" ? data.scoreObjective : state.scoreObjective;
      state.functionPath = typeof data.functionPath === "string" ? data.functionPath : state.functionPath;
      state.highNotes = [];
      state.lowNotes = [];
      state.notes = {};
      state.nextId = 1;

      const restoreNotes = (list, target) => {
        if (!Array.isArray(list)) return;
        list.forEach(item => {
          if (!item || typeof item !== "object") return;
          const id = Number(item.id);
          const noteId = Number.isFinite(id) ? id : state.nextId++;
          const note = {
            id: noteId,
            label: typeof item.label === "string" ? item.label : "C3",
            tag: typeof item.tag === "string" ? item.tag : "",
            manualTag: !!item.manualTag
          };
          target.push(note);
          const savedTicks = data.notes && data.notes[noteId];
          if (Array.isArray(savedTicks)) {
            state.notes[noteId] = new Set(savedTicks.map(Number).filter(Number.isFinite));
          } else {
            state.notes[noteId] = new Set();
          }
          state.nextId = Math.max(state.nextId, noteId + 1);
        });
      };

      restoreNotes(data.highNotes, state.highNotes);
      restoreNotes(data.lowNotes, state.lowNotes);

      elements.bars.value = state.bars;
      elements.barsRange.value = state.bars;
      elements.startTick.value = state.startTick;
      elements.scoreHolder.value = state.scoreHolder;
      elements.scoreObjective.value = state.scoreObjective;
      elements.functionPath.value = state.functionPath;
      elements.autoTag.checked = state.autoTag;
      elements.loopToggle.checked = state.loopEnabled;
      return true;
    }

    function labelToTag(label) {
      const match = label.trim().match(/^([A-Ga-g])(#?)(-?\d+)$/);
      if (!match) return "";
      const letter = match[1].toLowerCase();
      const sharp = match[2] ? "s" : "";
      const octave = match[3];
      return `piano_note_${letter}${sharp}${octave}`;
    }

    function normalizeLabel(label) {
      const match = label.trim().match(/^([A-Ga-g])(#?)(-?\d+)$/);
      if (!match) return null;
      const letter = match[1].toUpperCase();
      const sharp = match[2] ? "#" : "";
      const octave = match[3];
      return `${letter}${sharp}${octave}`;
    }


    function toggleSharp(label) {
      const match = label.trim().match(/^([A-Ga-g])(#?)(-?\d+)$/);
      if (!match) return label;
      const letter = match[1].toUpperCase();
      const hasSharp = !!match[2];
      const octave = match[3];
      return `${letter}${hasSharp ? "" : "#"}${octave}`;
    }

    function addNote(hand, label) {
      const note = {
        id: state.nextId++,
        label,
        tag: state.autoTag ? labelToTag(label) : "",
        manualTag: false
      };
      state[hand].push(note);
      state.notes[note.id] = new Set();
    }

    function removeNote(hand, id) {
      state[hand] = state[hand].filter(note => note.id !== id);
      delete state.notes[id];
    }

    function renderMapping(hand, container) {
      container.innerHTML = "";
      state[hand].forEach(note => {
        const row = document.createElement("div");
        row.className = "map-row";
        row.innerHTML = `
          <button class="mini" data-action="sharp" data-id="${note.id}">#</button>
          <input type="text" class="map-label" data-id="${note.id}" value="${note.label}" />
          <input type="text" class="map-tag" data-id="${note.id}" value="${note.tag}" />
          <button class="mini" data-action="remove" data-id="${note.id}">x</button>
        `;
        container.appendChild(row);
      });
    }

    function renderLabels(hand, container) {
      container.innerHTML = "";
      state[hand].forEach(note => {
        const row = document.createElement("div");
        row.textContent = note.label;
        container.appendChild(row);
      });
    }

    function renderTimeline(container) {
      const totalTicks = state.bars * state.ticksPerBar;
      container.style.setProperty("--cols", totalTicks);
      container.innerHTML = "";
      for (let tick = 0; tick < totalTicks; tick++) {
        const span = document.createElement("div");
        const classes = ["tick"];
        if (tick % state.ticksPerBar === 0) classes.push("bar-start");
        if (tick === state.startTick) classes.push("start");
        span.className = classes.join(" ");
        span.textContent = tick + 1;
        span.dataset.tick = tick;
        container.appendChild(span);
      }
    }

    function renderGrid(hand, container) {
      const totalTicks = state.bars * state.ticksPerBar;
      container.style.setProperty("--cols", totalTicks);
      container.innerHTML = "";
      state[hand].forEach(note => {
        for (let tick = 0; tick < totalTicks; tick++) {
          const cell = document.createElement("button");
          cell.className = "cell";
          if (tick % state.ticksPerBar === 0) cell.classList.add("bar-start");
          if (tick % 4 === 0) cell.classList.add("beat");
          if (state.notes[note.id] && state.notes[note.id].has(tick)) {
            cell.classList.add("on");
          }
          cell.dataset.id = note.id;
          cell.dataset.tick = tick;
          cell.setAttribute("aria-label", `${note.label} tick ${tick}`);
          container.appendChild(cell);
        }
      });
    }

    function countNotes(hand) {
      let total = 0;
      state[hand].forEach(note => {
        total += state.notes[note.id] ? state.notes[note.id].size : 0;
      });
      return total;
    }

    function updateCounts() {
      elements.highCount.textContent = `${countNotes("highNotes")} notes`;
      elements.lowCount.textContent = `${countNotes("lowNotes")} notes`;
    }

    function updateOutput() {
      const lines = [];
      const totalTicks = state.bars * state.ticksPerBar;
      const orderedNotes = [...state.highNotes, ...state.lowNotes];
      let lastTick = -1;
      lines.push(
        `execute if score ${state.scoreHolder} ${state.scoreObjective} matches 0 run scoreboard players set ${state.scoreHolder} ${state.scoreObjective} ${state.startTick}`
      );
      for (let tick = 0; tick < totalTicks; tick++) {
        for (const note of orderedNotes) {
          const set = state.notes[note.id];
          if (!set || !set.has(tick)) continue;
          const tag = note.tag.trim();
          if (!tag) continue;
          lines.push(
            `execute if score ${state.scoreHolder} ${state.scoreObjective} matches ${tick} as @e[distance=..100,tag=${tag},limit=1,type=block_display] at @s run function ${state.functionPath}`
          );
          if (tick > lastTick) lastTick = tick;
        }
      }
      if (lastTick >= 0) {
        lines.push("");
        lines.push("# Stop after the last note.");
        if (state.loopEnabled) {
          lines.push(
            `execute if score ${state.scoreHolder} ${state.scoreObjective} matches ${lastTick + 1} run scoreboard players set ${state.scoreHolder} ${state.scoreObjective} ${state.startTick}`
          );
        } else {
          lines.push(
            `execute if score ${state.scoreHolder} ${state.scoreObjective} matches ${lastTick + 1} run function a05:piano/preset/stop`
          );
        }
      }
      elements.output.value = lines.join("\n");
      updateCounts();
      saveState();
    }

    function renderAll() {
      elements.bars.value = state.bars;
      elements.barsRange.value = state.bars;
      elements.startTick.max = Math.max(0, state.bars * state.ticksPerBar - 1);
      elements.startTick.value = state.startTick;
      elements.barsHint.textContent = `Total ticks: ${state.bars * state.ticksPerBar}`;
      renderMapping("highNotes", elements.highMap);
      renderMapping("lowNotes", elements.lowMap);
      renderLabels("highNotes", elements.highLabels);
      renderLabels("lowNotes", elements.lowLabels);
      renderTimeline(elements.highTimeline);
      renderTimeline(elements.lowTimeline);
      renderGrid("highNotes", elements.highGrid);
      renderGrid("lowNotes", elements.lowGrid);
      updateOutput();
      syncAllScroll(state.scrollLeft);
    }

    function handleMapInput(hand, event) {
      const id = Number(event.target.dataset.id);
      if (!id) return;
      const note = state[hand].find(item => item.id === id);
      if (!note) return;
      if (event.target.classList.contains("map-label")) {
        note.label = event.target.value.trim();
        if (state.autoTag && !note.manualTag) {
          note.tag = labelToTag(note.label);
        }
        renderAll();
        return;
      }
      if (event.target.classList.contains("map-tag")) {
        note.tag = event.target.value.trim();
        note.manualTag = true;
        updateOutput();
      }
    }

    function handleMapClick(hand, event) {
      const button = event.target.closest("button");
      if (!button) return;
      const id = Number(button.dataset.id);
      if (!id) return;
      if (button.dataset.action === "remove") {
        removeNote(hand, id);
        renderAll();
        return;
      }
      if (button.dataset.action === "sharp") {
        const note = state[hand].find(item => item.id === id);
        if (!note) return;
        note.label = toggleSharp(note.label);
        if (state.autoTag && !note.manualTag) {
          note.tag = labelToTag(note.label);
        }
        renderAll();
      }
    }

    function handleGridClick(event) {
      const cell = event.target.closest(".cell");
      if (!cell) return;
      const id = Number(cell.dataset.id);
      const tick = Number(cell.dataset.tick);
      if (!state.notes[id]) state.notes[id] = new Set();
      if (state.notes[id].has(tick)) {
        state.notes[id].delete(tick);
        cell.classList.remove("on");
      } else {
        state.notes[id].add(tick);
        cell.classList.add("on");
      }
      updateOutput();
    }

    function clearPlacedNotes() {
      Object.keys(state.notes).forEach(id => state.notes[id] = new Set());
    }

    function buildTagMaps() {
      const toMap = list => {
        const map = new Map();
        list.forEach(note => {
          const tag = note.tag.trim().toLowerCase();
          if (!tag) return;
          if (!map.has(tag)) map.set(tag, []);
          map.get(tag).push(note.id);
        });
        return map;
      };
      return {
        high: toMap(state.highNotes),
        low: toMap(state.lowNotes)
      };
    }

    function parseImport(text) {
      const entries = [];
      let maxTick = -1;
      let startTick = null;
      const lines = text.split(/\r?\n/);
      for (const raw of lines) {
        const line = raw.trim();
        if (!line) continue;

        const startMatch = line.match(/scoreboard players set\s+(\S+)\s+(\S+)\s+(-?\d+)/);
        if (startMatch) {
          const value = Number(startMatch[3]);
          if (Number.isFinite(value)) startTick = value;
        }

        const tickMatch = line.match(/matches\s+(-?\d+)/);
        const tagMatch = line.match(/tag=([^,\]]+)/);
        if (!tickMatch || !tagMatch) continue;
        const tick = Number(tickMatch[1]);
        const tag = tagMatch[1].trim().toLowerCase();
        if (!Number.isFinite(tick) || !tag) continue;
        entries.push({ tick, tag });
        if (tick > maxTick) maxTick = tick;
      }
      return { entries, maxTick, startTick };
    }

    function tagToLabel(tag) {
      const match = tag.match(/^piano_note_([a-g])([s]?)(-?\d+)$/i);
      if (!match) return null;
      const letter = match[1].toUpperCase();
      const sharp = match[2] ? "#" : "";
      const octave = match[3];
      return `${letter}${sharp}${octave}`;
    }

    function findNoteByLabel(list, label) {
      const target = label.toUpperCase();
      return list.find(note => note.label.trim().toUpperCase() === target) || null;
    }

    function findNoteById(id) {
      return state.highNotes.find(note => note.id === id) || state.lowNotes.find(note => note.id === id) || null;
    }

    function importMcfunction(text) {
      const parsed = parseImport(text);
      if (!parsed.entries.length) return;

      if (parsed.maxTick >= 0) {
        const neededBars = Math.min(1024, Math.max(1, Math.ceil((parsed.maxTick + 1) / state.ticksPerBar)));
        state.bars = neededBars;
      }

      if (parsed.startTick !== null) {
        const maxTick = state.bars * state.ticksPerBar - 1;
        state.startTick = Math.min(Math.max(0, parsed.startTick), Math.max(0, maxTick));
      }

      clearPlacedNotes();
      const tagMaps = buildTagMaps();
      parsed.entries.forEach(entry => {
        const highIds = tagMaps.high.get(entry.tag);
        const lowIds = tagMaps.low.get(entry.tag);
        let targetId = null;
        if (highIds && lowIds && (entry.tag === "piano_note_c2" || entry.tag === "piano_note_cs2")) {
          targetId = highIds[0];
        } else if (highIds) {
          targetId = highIds[0];
        } else if (lowIds) {
          targetId = lowIds[0];
        }
        if (!targetId) {
          const label = tagToLabel(entry.tag);
          if (label) {
            const highMatch = findNoteByLabel(state.highNotes, label);
            const lowMatch = findNoteByLabel(state.lowNotes, label);
            let chosen = null;
            if (highMatch && lowMatch) {
              chosen = highMatch;
            } else {
              chosen = highMatch || lowMatch;
            }

            if (!chosen && label.includes("#")) {
              const naturalLabel = label.replace("#", "");
              const highNatural = findNoteByLabel(state.highNotes, naturalLabel);
              const lowNatural = findNoteByLabel(state.lowNotes, naturalLabel);
              if (highNatural && lowNatural) {
                chosen = highNatural;
              } else {
                chosen = highNatural || lowNatural;
              }
              if (chosen) {
                chosen.label = label;
              }
            }

            if (chosen) {
              const desiredTag = state.autoTag && !chosen.manualTag ? labelToTag(chosen.label) : entry.tag;
              if (desiredTag && chosen.tag.trim().toLowerCase() !== desiredTag.toLowerCase()) {
                chosen.tag = desiredTag;
                if (!(state.autoTag && !chosen.manualTag)) {
                  chosen.manualTag = true;
                }
              }
              const map = state.highNotes.includes(chosen) ? tagMaps.high : tagMaps.low;
              const tagKey = desiredTag.toLowerCase();
              if (tagKey) {
                if (!map.has(tagKey)) map.set(tagKey, []);
                if (!map.get(tagKey).includes(chosen.id)) map.get(tagKey).push(chosen.id);
              }
              targetId = chosen.id;
            }
          }
        }
        if (!targetId) return;
        const noteObj = findNoteById(targetId);
        if (noteObj && entry.tag.includes("piano_note_") && entry.tag.includes("s")) {
          const sharpLabel = tagToLabel(entry.tag);
          if (sharpLabel && !noteObj.label.includes("#")) {
            noteObj.label = sharpLabel;
            if (state.autoTag && !noteObj.manualTag) {
              noteObj.tag = labelToTag(sharpLabel);
            } else {
              noteObj.tag = entry.tag;
              noteObj.manualTag = true;
            }
          }
        }
        if (!state.notes[targetId]) state.notes[targetId] = new Set();
        state.notes[targetId].add(entry.tick);
      });

      renderAll();
    }

    function init() {
      const loaded = loadState();
      if (!loaded) {
        const highBottomToTop = [
          "C2", "D2", "E2", "F4",
          "G3", "A3", "B3",
          "C3", "D3", "E3", "F3",
          "G4", "A4", "B4",
          "C4", "D4", "E4", "F4"
        ];
        const lowTopToBottom = [
          "C2", "B2", "A2", "G2",
          "F2", "E1", "D1", "C1",
          "B1", "A1", "G1", "F1"
        ];
        highBottomToTop.slice().reverse().forEach(note => addNote("highNotes", note));
        lowTopToBottom.forEach(note => addNote("lowNotes", note));
      }
      renderAll();
    }

    function setBars(value) {
      const safe = Number.isFinite(value) && value > 0 ? Math.min(Math.max(1, value), 1024) : 1;
      state.bars = safe;
      const maxTick = state.bars * state.ticksPerBar - 1;
      if (state.startTick > maxTick) state.startTick = Math.max(0, maxTick);
      elements.bars.value = safe;
      elements.barsRange.value = safe;
      renderAll();
    }

    function setStartTick(value) {
      const totalTicks = state.bars * state.ticksPerBar;
      const maxTick = Math.max(0, totalTicks - 1);
      const raw = Number.isFinite(value) ? Math.floor(value) : 0;
      state.startTick = Math.min(Math.max(0, raw), maxTick);
      renderAll();
    }

    elements.bars.addEventListener("input", event => setBars(Number(event.target.value)));
    elements.barsRange.addEventListener("input", event => setBars(Number(event.target.value)));
    elements.startTick.addEventListener("input", event => setStartTick(Number(event.target.value)));

    function handleTimelineClick(event) {
      const tickEl = event.target.closest(".tick");
      if (!tickEl || tickEl.dataset.tick === undefined) return;
      setStartTick(Number(tickEl.dataset.tick));
    }

    elements.scoreHolder.addEventListener("input", event => {
      state.scoreHolder = event.target.value.trim() || "#piano_song_time";
      updateOutput();
    });

    elements.scoreObjective.addEventListener("input", event => {
      state.scoreObjective = event.target.value.trim() || "piano_song_time";
      updateOutput();
    });

    elements.functionPath.addEventListener("input", event => {
      state.functionPath = event.target.value.trim() || "a05:piano/press_key";
      updateOutput();
    });

    elements.loopToggle.addEventListener("change", event => {
      state.loopEnabled = event.target.checked;
      updateOutput();
    });

    elements.autoTag.addEventListener("change", event => {
      state.autoTag = event.target.checked;
      if (state.autoTag) {
        [...state.highNotes, ...state.lowNotes].forEach(note => {
          if (!note.manualTag) {
            note.tag = labelToTag(note.label);
          }
        });
      }
      renderAll();
    });

    elements.highMap.addEventListener("input", event => handleMapInput("highNotes", event));
    elements.lowMap.addEventListener("input", event => handleMapInput("lowNotes", event));
    elements.highMap.addEventListener("click", event => handleMapClick("highNotes", event));
    elements.lowMap.addEventListener("click", event => handleMapClick("lowNotes", event));
    elements.highTimeline.addEventListener("click", handleTimelineClick);
    elements.lowTimeline.addEventListener("click", handleTimelineClick);
    elements.highGrid.addEventListener("click", handleGridClick);
    elements.lowGrid.addEventListener("click", handleGridClick);

    elements.addHigh.addEventListener("click", () => {
      addNote("highNotes", "C5");
      renderAll();
    });

    elements.addLow.addEventListener("click", () => {
      addNote("lowNotes", "C3");
      renderAll();
    });

    elements.clearAll.addEventListener("click", () => {
      clearPlacedNotes();
      renderAll();
    });

    elements.resetStorage.addEventListener("click", () => {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (error) {
        /* ignore storage errors */
      }
      location.reload();
    });

    elements.copyOutput.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(elements.output.value);
        elements.copyOutput.textContent = "Copied";
        setTimeout(() => { elements.copyOutput.textContent = "Copy to clipboard"; }, 1200);
      } catch (error) {
        elements.copyOutput.textContent = "Copy failed";
        setTimeout(() => { elements.copyOutput.textContent = "Copy to clipboard"; }, 1600);
      }
    });

    elements.downloadOutput.addEventListener("click", () => {
      const blob = new Blob([elements.output.value], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "experience_intro.mcfunction";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(link.href);
    });

    elements.importBtn.addEventListener("click", () => {
      importMcfunction(elements.importInput.value || "");
    });

    elements.clearImport.addEventListener("click", () => {
      elements.importInput.value = "";
    });

    function setupScrollSyncAll() {
      const wraps = Array.from(document.querySelectorAll(".scroll-wrap"));
      if (wraps.length < 2) return;
      wraps.forEach(wrap => {
        wrap.addEventListener("scroll", () => {
          if (scrollState.syncing) return;
          scrollState.syncing = true;
          const left = wrap.scrollLeft;
          wraps.forEach(other => {
            if (other !== wrap) other.scrollLeft = left;
          });
          scrollState.syncing = false;
          queueScrollSave(left);
        });
      });
    }

    function queueScrollSave(left) {
      state.scrollLeft = left;
      if (scrollState.saveTimer) clearTimeout(scrollState.saveTimer);
      scrollState.saveTimer = setTimeout(() => {
        saveState();
        scrollState.saveTimer = null;
      }, 150);
    }

    function syncAllScroll(left) {
      const wraps = Array.from(document.querySelectorAll(".scroll-wrap"));
      if (!wraps.length) return;
      scrollState.syncing = true;
      wraps.forEach(wrap => {
        wrap.scrollLeft = left;
      });
      scrollState.syncing = false;
    }

    init();
    setupScrollSyncAll();
  </script>
</body>
</html>
